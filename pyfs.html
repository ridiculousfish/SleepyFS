<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>
Pinefs - pyfs
</title>
</head>
<body>
<H3>pyfs</H3>
<p>
<pre>
Pyfs provides a view of Python namespace (rooted at sys.modules) as
a NFS filesystem.  The implementation is imperfect, because I can't
think of anything in Python which can be used for the 'fileid'
attribute or the filehandle, independent of either the contents of the
object or its place in the filesystem.  The compromise is to use a
cache (FileSystem._objs) to make sure that the same python directory
obj (defined as either an instance of a subclass of dict or dictproxy,
or an object which has a '__dict__' attribute) is always wrapped by
the same FileObj.  All other objects (e.g. Python integers, strings)
are wrapped by a new FileObj (with a new fileid) for each different
access path through the Python namespace.

In order to handle writing to immutable types (such as strings and
integers), each FileObj contains the parent dictionary and key through
which it was first encountered, and writing to regular files is
implemented by creating a new object and binding it as the new value
for that key in the parent dictionary.  (For writing to directories,
the dictionary is mutated in place.)  The new object's value is obtained
by stringifying the value (with str()), creating a new string by
replacing the indicated part of the old string, and then passing the
new string to type(val).  If the type object (e.g.  for functions)
doesn't accept a string as parameter, we report NFSERR_ACCES.  (Yes,
this is a bunch of overhead.)

For directories, instead of just using the __dict__, we probably
should track the logic used in 'dir' (or just call 'dir'), while being
aware that accesses to attributes returned from dir can raise
AttributeError (e.g. __slots__).  Currently, we don't implement access
to the __class__ attribute of class instances, attributes defined with
__slots__ (or other attributes defined by means of attribute
descriptors), or to dynamically-generated attributes generated by
manipulating __getattr__/__getattribute__.  (The general problem seems
insoluble, at least without an assist from the __members__ attribute.)

Note that hard links to non-directories don't work with this system.
(A hard link request is currently implemented as a copy.)  To fix this, a
FileObj could have a list of (parent_dict, key) tuples, and a write
would iterate over the list and rebind each parent_dict[key].

XXX This code isn't safe if the Python side mutates directories
exactly when the NFS code is reading them.  When it's rewritten to be
safe, test by pausing NFS code at important points (e.g. inside
refresh_dir), waiting for the user to mutate stuff at the python
console, and then signal to continue from console.

Here's a useless example (except for testing purposes):
find  .  -name __doc__ -noleaf  -exec grep "maxint" \{\} /dev/null \;
(executed in root of NFS mount)

Note that there are many paths through the Python namespace to the
module sys, which currently has the only docstring with maxint in it
(unless this module is imported), and that find prints all of them.
(pyfs returns the same filehandle and fileid each time, so it is
possible to realize they're all duplicates.)

</pre>
<p>
<a href="README.html">Back to Pinefs home page</a>
</body>
</html>